#!/usr/bin/perl -w
#
# Munin plugin for glusterfs 3.2+ 
# This plugin can graph:
#  - Open and maximum fd count
#  - Read performance per brick
#  - Write performance per brick
# 
#---------------------
# Examples
# Create a symbolic link to glusterfs_<brick>_<open|readperf|writeperf>
#       ln -s /usr/share/munin/plugins/glusterfs__ /etc/munin/plugins/glusterfs__open
#           graph open calls for all bricks
# 
#       ln -s /usr/share/munin/plugins/glusterfs__ /etc/munin/plugins/glusterfs_192.168.1.3_writeperf
#           graph write performance for brick on 192.168.1.3
# 
#---------------------
# 
# Add the following to your /etc/munin/plugin-conf.d/munin-node:
# 
#       [glusterfs_*]
#       user root                   # Mandatory
#       env.blocksize <blocksize>   # Optional
#       env.blockcount <blockcount> # Optional
# 
#---------------------
# Log
# Revision 0.1  01/31/2013
# -First version of the GlusterFS Munin plugin
#
#%# family=auto
#%# capabilities=autoconf

use strict;
use warnings;

my $Revision = 0.1;

my $DEBUG = 0;

my $Brick = "";  # Brick name found
my $Share = "";
my $Volume = "";
my $BlockSize = exists $ENV{'blocksize'} ? $ENV{'blocksize'} : "256"; # Block size for performance tests
my $BlockCount = exists $ENV{'blockcount'} ? $ENV{'blockcount'} : "1"; # Block count for performance tests
my $Type = "";  # Define what needs to be done

# Make sure the share name is defined
if ( ! defined $Share or $Share eq "none" ) {
  print "The share name must be defined in plugin-conf.d \n";
  exit 1;
}

# Parse out Brick number desired from file name and remove whitespace
my $Parameters = `basename $0 | sed 's/^glusterfs_//g'` ;
chomp $Parameters;
my ($v, $b, $t) = split( /_/, $Parameters );

if ( ! defined $v or $v eq "") {
  print "The volume name must be defined in plugin filename \n";
  exit 1;
} else {
  $Volume = $v;
}

if ( defined $b and $b ne "" ) {
  $Brick = $b;
}
if ( ! defined $t or $t eq "" ) {
  print "The type needs to be defined as one of the following: open|readperf|writeperf \n";
  exit 1;
} else {
  $Type = $t;
}

if ( $DEBUG == 1 ) { 
  print "Brick: $Brick; Type: $Type\n";
}

# Locate gluster command and remove whitespace
my $Command = `which gluster`;
chomp $Command;

if ( ! defined $Command or $Command eq "" ) {
  print "GlusterFS doesn't seem to be installed on your machine. Can't find 'gluster'.\n";
  exit 1;
}

# Use this to define future parameters to monitor
my %config = (
  open => {
    callparams => "open",
    label => '',
    title => "Volume $Volume: Open FD count",
    vlabel => 'FDs',
    graph_args => '--base 1000 -l 0',
    info_tag => "Open file connections",
    description => "Open file connections for Volume $Volume."
  },
  readperf => {
    callparams => "read-perf bs $BlockSize count $BlockCount",
    label => '',
    title => "Volume $Volume: Read performance",
    vlabel => 'MBps/sec',
    graph_args => '--base 1000 -l 0',
    info_tag => "Read performance",
    description => "Read performance for Volume $Volume."
  },
  writeperf => {
    callparams => "write-perf bs $BlockSize count $BlockCount",
    label => '',
    title => "Volume $Volume: Write performance",
    vlabel => 'MBps/sec',
    graph_args => '--base 1000 -l 0',
    info_tag => "Write performance",
    description => "Write performance for Volume $Volume."
  }
);

# Create Command parameters
my $CommandParams = " volume top $Volume ";
my $CommandBrickParams = "";
if ( defined $Brick and $Brick ne "" ) {
  $Brick = `gluster volume status ${Volume} | grep 'Brick ${Brick}:/' | awk '{print \$2}'`;
  $Brick =~ s/\n//;
  $CommandBrickParams = " brick ${Brick}";
}

$Command .= $CommandParams;
$Command .= $config{$Type}->{callparams};
$Command .= $CommandBrickParams;

my $CommandAdditionalParams = " list-cnt 0";
$Command .= $CommandAdditionalParams;

if ( $DEBUG == 1 ) { 
  print "Command: $Command\n";
}

# This will create a label name correctly
sub createLabelName {
  my $brickName = $_[0];
  return ($brickName);
}

# Read Output of gluster command
my @Output = qx($Command);

if ( $ARGV[0] and $ARGV[0] eq "autoconf" ) {
  my $foundBrick = 0;
  foreach my $Line (@Output) {
    $Line=~ s/\r//g;
    $Line=~ s/\n//g;

    #Find Brick name
    if ( $Line=~ /Brick: (.*)/i ) {
      $foundBrick = 1;
    }
  }
  if ( $foundBrick == 0 ) {
    print "no (No Bricks found!)\n";
    exit 1;
  }
  print "yes\n";
}

#Munin Config Options
if ( $ARGV[0] and $ARGV[0] eq "config" ) {
  print "graph_title $config{$Type}->{title}\n";
  print "graph_vlabel $config{$Type}->{vlabel}\n";
  print "graph_args $config{$Type}->{graph_args}\n";
  print "graph_scale yes\n";
  print "graph_category glusterfs\n";
  print "graph_info $config{$Type}->{description} <br />Generated by glusterfs_, Version $Revision<br />\n";

  foreach my $Line (@Output) {
    $Line=~ s/\r//g;
    $Line=~ s/\n//g;

    #Find Brick name
    if ( $Line=~ /Brick: (.*)/i ) {
      my ($brick) = ($1);
      my $bricklabel = createLabelName($brick);
      
      if ( $Type eq "open" ) {
        print "${bricklabel}_${Type}_current.label $brick $config{$Type}->{label}\n";
        print "${bricklabel}_${Type}_current.info $brick Current $config{$Type}->{info_tag}\n";
      } else {
        print "${bricklabel}_${Type}_throughput.label $brick $config{$Type}->{label}\n";
        print "${bricklabel}_${Type}_throughput.info $brick $config{$Type}->{info_tag}\n";
      }
    }
  }
  exit 0;
}

# Main function - returns values
# placeholder
my $bricklabel;

foreach my $Line (@Output) {
  $Line=~ s/\r//g;
  $Line=~ s/\n//g;

  #Find Brick name
  if ( $Line=~ /Brick: (.*)/i ) {
    my ($brick) = ($1);
    $bricklabel = createLabelName($brick);
  }
  
  if ( $Type eq "open" ) {
    if ( $Line=~ /Current\sopen\sfds:\s+(\d+),\sMax\sopen\sfds:\s+(\d+)/i ) {
      my ($current, $max) = ($1, $2);
      print "${bricklabel}_${Type}_current.value $current\n";
    }
  } else {
    if ( $Line=~ /Throughput\s+(\d+).(\d+)\s+MBps\s+time\s+(\d+).(\d+)\s+secs/i ) {
      my ($tpi, $tpf, $ti, $tf) = ($1, $2, $3, $4);
      print "${bricklabel}_${Type}_throughput.value $tpi.$tpf\n";
    }
  }
}

exit 0;
